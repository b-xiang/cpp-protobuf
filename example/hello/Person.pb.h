// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Person.proto

#ifndef PROTOBUF_Person_2eproto__INCLUDED
#define PROTOBUF_Person_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Person_2eproto();
void protobuf_AssignDesc_Person_2eproto();
void protobuf_ShutdownFile_Person_2eproto();

class Address;
class Person;

enum Person_MO {
  Person_MO_OK = 0,
  Person_MO_FAIL = 1
};
bool Person_MO_IsValid(int value);
const Person_MO Person_MO_MO_MIN = Person_MO_OK;
const Person_MO Person_MO_MO_MAX = Person_MO_FAIL;
const int Person_MO_MO_ARRAYSIZE = Person_MO_MO_MAX + 1;

const ::google::protobuf::EnumDescriptor* Person_MO_descriptor();
inline const ::std::string& Person_MO_Name(Person_MO value) {
  return ::google::protobuf::internal::NameOfEnum(
    Person_MO_descriptor(), value);
}
inline bool Person_MO_Parse(
    const ::std::string& name, Person_MO* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Person_MO>(
    Person_MO_descriptor(), name, value);
}
// ===================================================================

class Address : public ::google::protobuf::Message {
 public:
  Address();
  virtual ~Address();

  Address(const Address& from);

  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Address& default_instance();

  void Swap(Address* other);

  // implements Message ----------------------------------------------

  Address* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Address& from);
  void MergeFrom(const Address& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string streat = 1;
  inline bool has_streat() const;
  inline void clear_streat();
  static const int kStreatFieldNumber = 1;
  inline const ::std::string& streat() const;
  inline void set_streat(const ::std::string& value);
  inline void set_streat(const char* value);
  inline void set_streat(const char* value, size_t size);
  inline ::std::string* mutable_streat();
  inline ::std::string* release_streat();
  inline void set_allocated_streat(::std::string* streat);

  // required string room = 2;
  inline bool has_room() const;
  inline void clear_room();
  static const int kRoomFieldNumber = 2;
  inline const ::std::string& room() const;
  inline void set_room(const ::std::string& value);
  inline void set_room(const char* value);
  inline void set_room(const char* value, size_t size);
  inline ::std::string* mutable_room();
  inline ::std::string* release_room();
  inline void set_allocated_room(::std::string* room);

  // @@protoc_insertion_point(class_scope:Address)
 private:
  inline void set_has_streat();
  inline void clear_has_streat();
  inline void set_has_room();
  inline void clear_has_room();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* streat_;
  ::std::string* room_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Person_2eproto();
  friend void protobuf_AssignDesc_Person_2eproto();
  friend void protobuf_ShutdownFile_Person_2eproto();

  void InitAsDefaultInstance();
  static Address* default_instance_;
};
// -------------------------------------------------------------------

class Person : public ::google::protobuf::Message {
 public:
  Person();
  virtual ~Person();

  Person(const Person& from);

  inline Person& operator=(const Person& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Person& default_instance();

  void Swap(Person* other);

  // implements Message ----------------------------------------------

  Person* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Person& from);
  void MergeFrom(const Person& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Person_MO MO;
  static const MO OK = Person_MO_OK;
  static const MO FAIL = Person_MO_FAIL;
  static inline bool MO_IsValid(int value) {
    return Person_MO_IsValid(value);
  }
  static const MO MO_MIN =
    Person_MO_MO_MIN;
  static const MO MO_MAX =
    Person_MO_MO_MAX;
  static const int MO_ARRAYSIZE =
    Person_MO_MO_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MO_descriptor() {
    return Person_MO_descriptor();
  }
  static inline const ::std::string& MO_Name(MO value) {
    return Person_MO_Name(value);
  }
  static inline bool MO_Parse(const ::std::string& name,
      MO* value) {
    return Person_MO_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional float salary = 5;
  inline bool has_salary() const;
  inline void clear_salary();
  static const int kSalaryFieldNumber = 5;
  inline float salary() const;
  inline void set_salary(float value);

  // optional double age = 4;
  inline bool has_age() const;
  inline void clear_age();
  static const int kAgeFieldNumber = 4;
  inline double age() const;
  inline void set_age(double value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated int32 friends = 3;
  inline int friends_size() const;
  inline void clear_friends();
  static const int kFriendsFieldNumber = 3;
  inline ::google::protobuf::int32 friends(int index) const;
  inline void set_friends(int index, ::google::protobuf::int32 value);
  inline void add_friends(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      friends() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_friends();

  // required bool haschild = 6;
  inline bool has_haschild() const;
  inline void clear_haschild();
  static const int kHaschildFieldNumber = 6;
  inline bool haschild() const;
  inline void set_haschild(bool value);

  // required uint32 ii32 = 9;
  inline bool has_ii32() const;
  inline void clear_ii32();
  static const int kIi32FieldNumber = 9;
  inline ::google::protobuf::uint32 ii32() const;
  inline void set_ii32(::google::protobuf::uint32 value);

  // required uint64 ii64 = 10;
  inline bool has_ii64() const;
  inline void clear_ii64();
  static const int kIi64FieldNumber = 10;
  inline ::google::protobuf::uint64 ii64() const;
  inline void set_ii64(::google::protobuf::uint64 value);

  // required int32 i32 = 13;
  inline bool has_i32() const;
  inline void clear_i32();
  static const int kI32FieldNumber = 13;
  inline ::google::protobuf::int32 i32() const;
  inline void set_i32(::google::protobuf::int32 value);

  // required int64 i64 = 14;
  inline bool has_i64() const;
  inline void clear_i64();
  static const int kI64FieldNumber = 14;
  inline ::google::protobuf::int64 i64() const;
  inline void set_i64(::google::protobuf::int64 value);

  // required .Person.MO ii = 16;
  inline bool has_ii() const;
  inline void clear_ii();
  static const int kIiFieldNumber = 16;
  inline ::Person_MO ii() const;
  inline void set_ii(::Person_MO value);

  // optional .Address One = 17;
  inline bool has_one() const;
  inline void clear_one();
  static const int kOneFieldNumber = 17;
  inline const ::Address& one() const;
  inline ::Address* mutable_one();
  inline ::Address* release_one();
  inline void set_allocated_one(::Address* one);

  // repeated .Address address = 15;
  inline int address_size() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 15;
  inline const ::Address& address(int index) const;
  inline ::Address* mutable_address(int index);
  inline ::Address* add_address();
  inline const ::google::protobuf::RepeatedPtrField< ::Address >&
      address() const;
  inline ::google::protobuf::RepeatedPtrField< ::Address >*
      mutable_address();

  // repeated int32 aInt = 18;
  inline int aint_size() const;
  inline void clear_aint();
  static const int kAIntFieldNumber = 18;
  inline ::google::protobuf::int32 aint(int index) const;
  inline void set_aint(int index, ::google::protobuf::int32 value);
  inline void add_aint(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      aint() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_aint();

  // repeated float aFloat = 19;
  inline int afloat_size() const;
  inline void clear_afloat();
  static const int kAFloatFieldNumber = 19;
  inline float afloat(int index) const;
  inline void set_afloat(int index, float value);
  inline void add_afloat(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      afloat() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_afloat();

  // repeated double aDouble = 20;
  inline int adouble_size() const;
  inline void clear_adouble();
  static const int kADoubleFieldNumber = 20;
  inline double adouble(int index) const;
  inline void set_adouble(int index, double value);
  inline void add_adouble(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      adouble() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_adouble();

  // repeated string aString = 21;
  inline int astring_size() const;
  inline void clear_astring();
  static const int kAStringFieldNumber = 21;
  inline const ::std::string& astring(int index) const;
  inline ::std::string* mutable_astring(int index);
  inline void set_astring(int index, const ::std::string& value);
  inline void set_astring(int index, const char* value);
  inline void set_astring(int index, const char* value, size_t size);
  inline ::std::string* add_astring();
  inline void add_astring(const ::std::string& value);
  inline void add_astring(const char* value);
  inline void add_astring(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& astring() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_astring();

  // @@protoc_insertion_point(class_scope:Person)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_salary();
  inline void clear_has_salary();
  inline void set_has_age();
  inline void clear_has_age();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_haschild();
  inline void clear_has_haschild();
  inline void set_has_ii32();
  inline void clear_has_ii32();
  inline void set_has_ii64();
  inline void clear_has_ii64();
  inline void set_has_i32();
  inline void clear_has_i32();
  inline void set_has_i64();
  inline void clear_has_i64();
  inline void set_has_ii();
  inline void clear_has_ii();
  inline void set_has_one();
  inline void clear_has_one();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  float salary_;
  double age_;
  ::std::string* name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > friends_;
  bool haschild_;
  ::google::protobuf::uint32 ii32_;
  ::google::protobuf::uint64 ii64_;
  ::google::protobuf::int64 i64_;
  ::google::protobuf::int32 i32_;
  int ii_;
  ::Address* one_;
  ::google::protobuf::RepeatedPtrField< ::Address > address_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > aint_;
  ::google::protobuf::RepeatedField< float > afloat_;
  ::google::protobuf::RepeatedField< double > adouble_;
  ::google::protobuf::RepeatedPtrField< ::std::string> astring_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_Person_2eproto();
  friend void protobuf_AssignDesc_Person_2eproto();
  friend void protobuf_ShutdownFile_Person_2eproto();

  void InitAsDefaultInstance();
  static Person* default_instance_;
};
// ===================================================================


// ===================================================================

// Address

// required string streat = 1;
inline bool Address::has_streat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Address::set_has_streat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Address::clear_has_streat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Address::clear_streat() {
  if (streat_ != &::google::protobuf::internal::kEmptyString) {
    streat_->clear();
  }
  clear_has_streat();
}
inline const ::std::string& Address::streat() const {
  return *streat_;
}
inline void Address::set_streat(const ::std::string& value) {
  set_has_streat();
  if (streat_ == &::google::protobuf::internal::kEmptyString) {
    streat_ = new ::std::string;
  }
  streat_->assign(value);
}
inline void Address::set_streat(const char* value) {
  set_has_streat();
  if (streat_ == &::google::protobuf::internal::kEmptyString) {
    streat_ = new ::std::string;
  }
  streat_->assign(value);
}
inline void Address::set_streat(const char* value, size_t size) {
  set_has_streat();
  if (streat_ == &::google::protobuf::internal::kEmptyString) {
    streat_ = new ::std::string;
  }
  streat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Address::mutable_streat() {
  set_has_streat();
  if (streat_ == &::google::protobuf::internal::kEmptyString) {
    streat_ = new ::std::string;
  }
  return streat_;
}
inline ::std::string* Address::release_streat() {
  clear_has_streat();
  if (streat_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = streat_;
    streat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Address::set_allocated_streat(::std::string* streat) {
  if (streat_ != &::google::protobuf::internal::kEmptyString) {
    delete streat_;
  }
  if (streat) {
    set_has_streat();
    streat_ = streat;
  } else {
    clear_has_streat();
    streat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string room = 2;
inline bool Address::has_room() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Address::set_has_room() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Address::clear_has_room() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Address::clear_room() {
  if (room_ != &::google::protobuf::internal::kEmptyString) {
    room_->clear();
  }
  clear_has_room();
}
inline const ::std::string& Address::room() const {
  return *room_;
}
inline void Address::set_room(const ::std::string& value) {
  set_has_room();
  if (room_ == &::google::protobuf::internal::kEmptyString) {
    room_ = new ::std::string;
  }
  room_->assign(value);
}
inline void Address::set_room(const char* value) {
  set_has_room();
  if (room_ == &::google::protobuf::internal::kEmptyString) {
    room_ = new ::std::string;
  }
  room_->assign(value);
}
inline void Address::set_room(const char* value, size_t size) {
  set_has_room();
  if (room_ == &::google::protobuf::internal::kEmptyString) {
    room_ = new ::std::string;
  }
  room_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Address::mutable_room() {
  set_has_room();
  if (room_ == &::google::protobuf::internal::kEmptyString) {
    room_ = new ::std::string;
  }
  return room_;
}
inline ::std::string* Address::release_room() {
  clear_has_room();
  if (room_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = room_;
    room_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Address::set_allocated_room(::std::string* room) {
  if (room_ != &::google::protobuf::internal::kEmptyString) {
    delete room_;
  }
  if (room) {
    set_has_room();
    room_ = room;
  } else {
    clear_has_room();
    room_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Person

// required int32 id = 1;
inline bool Person::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Person::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Person::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Person::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Person::id() const {
  return id_;
}
inline void Person::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional float salary = 5;
inline bool Person::has_salary() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Person::set_has_salary() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Person::clear_has_salary() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Person::clear_salary() {
  salary_ = 0;
  clear_has_salary();
}
inline float Person::salary() const {
  return salary_;
}
inline void Person::set_salary(float value) {
  set_has_salary();
  salary_ = value;
}

// optional double age = 4;
inline bool Person::has_age() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Person::set_has_age() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Person::clear_has_age() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Person::clear_age() {
  age_ = 0;
  clear_has_age();
}
inline double Person::age() const {
  return age_;
}
inline void Person::set_age(double value) {
  set_has_age();
  age_ = value;
}

// optional string name = 2;
inline bool Person::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Person::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Person::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Person::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Person::name() const {
  return *name_;
}
inline void Person::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Person::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Person::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Person::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Person::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Person::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated int32 friends = 3;
inline int Person::friends_size() const {
  return friends_.size();
}
inline void Person::clear_friends() {
  friends_.Clear();
}
inline ::google::protobuf::int32 Person::friends(int index) const {
  return friends_.Get(index);
}
inline void Person::set_friends(int index, ::google::protobuf::int32 value) {
  friends_.Set(index, value);
}
inline void Person::add_friends(::google::protobuf::int32 value) {
  friends_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Person::friends() const {
  return friends_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Person::mutable_friends() {
  return &friends_;
}

// required bool haschild = 6;
inline bool Person::has_haschild() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Person::set_has_haschild() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Person::clear_has_haschild() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Person::clear_haschild() {
  haschild_ = false;
  clear_has_haschild();
}
inline bool Person::haschild() const {
  return haschild_;
}
inline void Person::set_haschild(bool value) {
  set_has_haschild();
  haschild_ = value;
}

// required uint32 ii32 = 9;
inline bool Person::has_ii32() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Person::set_has_ii32() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Person::clear_has_ii32() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Person::clear_ii32() {
  ii32_ = 0u;
  clear_has_ii32();
}
inline ::google::protobuf::uint32 Person::ii32() const {
  return ii32_;
}
inline void Person::set_ii32(::google::protobuf::uint32 value) {
  set_has_ii32();
  ii32_ = value;
}

// required uint64 ii64 = 10;
inline bool Person::has_ii64() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Person::set_has_ii64() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Person::clear_has_ii64() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Person::clear_ii64() {
  ii64_ = GOOGLE_ULONGLONG(0);
  clear_has_ii64();
}
inline ::google::protobuf::uint64 Person::ii64() const {
  return ii64_;
}
inline void Person::set_ii64(::google::protobuf::uint64 value) {
  set_has_ii64();
  ii64_ = value;
}

// required int32 i32 = 13;
inline bool Person::has_i32() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Person::set_has_i32() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Person::clear_has_i32() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Person::clear_i32() {
  i32_ = 0;
  clear_has_i32();
}
inline ::google::protobuf::int32 Person::i32() const {
  return i32_;
}
inline void Person::set_i32(::google::protobuf::int32 value) {
  set_has_i32();
  i32_ = value;
}

// required int64 i64 = 14;
inline bool Person::has_i64() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Person::set_has_i64() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Person::clear_has_i64() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Person::clear_i64() {
  i64_ = GOOGLE_LONGLONG(0);
  clear_has_i64();
}
inline ::google::protobuf::int64 Person::i64() const {
  return i64_;
}
inline void Person::set_i64(::google::protobuf::int64 value) {
  set_has_i64();
  i64_ = value;
}

// required .Person.MO ii = 16;
inline bool Person::has_ii() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Person::set_has_ii() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Person::clear_has_ii() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Person::clear_ii() {
  ii_ = 0;
  clear_has_ii();
}
inline ::Person_MO Person::ii() const {
  return static_cast< ::Person_MO >(ii_);
}
inline void Person::set_ii(::Person_MO value) {
  assert(::Person_MO_IsValid(value));
  set_has_ii();
  ii_ = value;
}

// optional .Address One = 17;
inline bool Person::has_one() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Person::set_has_one() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Person::clear_has_one() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Person::clear_one() {
  if (one_ != NULL) one_->::Address::Clear();
  clear_has_one();
}
inline const ::Address& Person::one() const {
  return one_ != NULL ? *one_ : *default_instance_->one_;
}
inline ::Address* Person::mutable_one() {
  set_has_one();
  if (one_ == NULL) one_ = new ::Address;
  return one_;
}
inline ::Address* Person::release_one() {
  clear_has_one();
  ::Address* temp = one_;
  one_ = NULL;
  return temp;
}
inline void Person::set_allocated_one(::Address* one) {
  delete one_;
  one_ = one;
  if (one) {
    set_has_one();
  } else {
    clear_has_one();
  }
}

// repeated .Address address = 15;
inline int Person::address_size() const {
  return address_.size();
}
inline void Person::clear_address() {
  address_.Clear();
}
inline const ::Address& Person::address(int index) const {
  return address_.Get(index);
}
inline ::Address* Person::mutable_address(int index) {
  return address_.Mutable(index);
}
inline ::Address* Person::add_address() {
  return address_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Address >&
Person::address() const {
  return address_;
}
inline ::google::protobuf::RepeatedPtrField< ::Address >*
Person::mutable_address() {
  return &address_;
}

// repeated int32 aInt = 18;
inline int Person::aint_size() const {
  return aint_.size();
}
inline void Person::clear_aint() {
  aint_.Clear();
}
inline ::google::protobuf::int32 Person::aint(int index) const {
  return aint_.Get(index);
}
inline void Person::set_aint(int index, ::google::protobuf::int32 value) {
  aint_.Set(index, value);
}
inline void Person::add_aint(::google::protobuf::int32 value) {
  aint_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Person::aint() const {
  return aint_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Person::mutable_aint() {
  return &aint_;
}

// repeated float aFloat = 19;
inline int Person::afloat_size() const {
  return afloat_.size();
}
inline void Person::clear_afloat() {
  afloat_.Clear();
}
inline float Person::afloat(int index) const {
  return afloat_.Get(index);
}
inline void Person::set_afloat(int index, float value) {
  afloat_.Set(index, value);
}
inline void Person::add_afloat(float value) {
  afloat_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
Person::afloat() const {
  return afloat_;
}
inline ::google::protobuf::RepeatedField< float >*
Person::mutable_afloat() {
  return &afloat_;
}

// repeated double aDouble = 20;
inline int Person::adouble_size() const {
  return adouble_.size();
}
inline void Person::clear_adouble() {
  adouble_.Clear();
}
inline double Person::adouble(int index) const {
  return adouble_.Get(index);
}
inline void Person::set_adouble(int index, double value) {
  adouble_.Set(index, value);
}
inline void Person::add_adouble(double value) {
  adouble_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Person::adouble() const {
  return adouble_;
}
inline ::google::protobuf::RepeatedField< double >*
Person::mutable_adouble() {
  return &adouble_;
}

// repeated string aString = 21;
inline int Person::astring_size() const {
  return astring_.size();
}
inline void Person::clear_astring() {
  astring_.Clear();
}
inline const ::std::string& Person::astring(int index) const {
  return astring_.Get(index);
}
inline ::std::string* Person::mutable_astring(int index) {
  return astring_.Mutable(index);
}
inline void Person::set_astring(int index, const ::std::string& value) {
  astring_.Mutable(index)->assign(value);
}
inline void Person::set_astring(int index, const char* value) {
  astring_.Mutable(index)->assign(value);
}
inline void Person::set_astring(int index, const char* value, size_t size) {
  astring_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Person::add_astring() {
  return astring_.Add();
}
inline void Person::add_astring(const ::std::string& value) {
  astring_.Add()->assign(value);
}
inline void Person::add_astring(const char* value) {
  astring_.Add()->assign(value);
}
inline void Person::add_astring(const char* value, size_t size) {
  astring_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Person::astring() const {
  return astring_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Person::mutable_astring() {
  return &astring_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Person_MO>() {
  return ::Person_MO_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Person_2eproto__INCLUDED
